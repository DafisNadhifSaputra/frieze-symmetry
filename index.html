<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simetri Frieze (v1.8 - Spectrum Color Picker)</title>
    <!-- Include iro.js Color Picker Library -->
    <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>

    <style>
        :root {
            /* Light Mode Colors */
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --card-border: #dee2e6;
            --canvas-border: #ced4da;
            --text-color: #212529;
            --text-muted: #6c757d;
            --primary-color: #0d6efd;
            --primary-hover: #0b5ed7;
            --primary-text: #fff;
            --danger-color: #dc3545;
            --danger-hover: #bb2d3b;
            --success-color: #198754;
            --success-hover: #157347;
            --info-color: #0dcaf0;
            --info-hover: #0aa3c2; /* Adjusted hover for better contrast */
            --info-text: #000; /* Text color for info button */
            --secondary-color: #6c757d;
            --secondary-hover: #5c636a;
            --secondary-text: #fff;
            --light-color: #f8f9fa;
            --light-hover: #e2e6ea;
            --light-text: #000;
            --hover-bg: #e9ecef;
            --selected-bg: #cfe2ff;
            --selected-border: #9ec5fe;
            --selected-text: #052c65; /* Darker text for selected */
            --disabled-opacity: 0.65;
            --shadow-color: rgba(0, 0, 0, 0.075);
            --input-border: #ced4da;
            --input-focus-border: #86b7fe;
            --input-focus-shadow: rgba(13, 110, 253, 0.25);
            --modal-backdrop: rgba(0, 0, 0, 0.5);
            --modal-shadow: rgba(0, 0, 0, 0.15);
            --picker-border-color: #eee; /* Border for color picker */

            /* Grid Colors (Light) */
            --grid-color: #b0bec5;
            --grid-mid-color: #90a4ae;
            --grid-reflect-color: #f1948a;
            --grid-glide-color: #76d7c4;
            --grid-rot-color: #af7ac5;

            /* Base Variables */
            --canvas-width: 1264px;
            --canvas-height: 140px;
            --controls-max-width: 1264px;
            --border-radius: 0.375rem; /* Bootstrap's default */
            --spacing: 1rem;
            --transition-speed: 0.15s;
        }

        /* Dark Mode Colors */
        body.dark-mode {
            --bg-color: #1a1a1a;
            --card-bg: #2c2c2c;
            --card-border: #444;
            --canvas-border: #555;
            --text-color: #e0e0e0;
            --text-muted: #adb5bd;
            --primary-color: #3b82f6; /* Brighter blue for dark mode */
            --primary-hover: #2563eb;
            --primary-text: #fff;
            --danger-color: #f87171; /* Brighter red */
            --danger-hover: #ef4444;
            --success-color: #4ade80; /* Brighter green */
            --success-hover: #22c55e;
            --info-color: #67e8f9; /* Brighter cyan */
            --info-hover: #22d3ee;
            --info-text: #000;
            --secondary-color: #6b7280; /* Adjusted gray */
            --secondary-hover: #4b5563;
            --secondary-text: #fff;
            --light-color: #4b5563; /* Darker 'light' */
            --light-hover: #5e6a7a;
            --light-text: #e0e0e0;
            --hover-bg: #3a3a3a;
            --selected-bg: #374151; /* Darker selected */
            --selected-border: #4b5563;
            --selected-text: #93c5fd; /* Lighter blue selected text */
            --disabled-opacity: 0.5;
            --shadow-color: rgba(255, 255, 255, 0.05);
            --input-border: #555;
            --input-focus-border: #3b82f6;
            --input-focus-shadow: rgba(59, 130, 246, 0.3);
            --modal-backdrop: rgba(0, 0, 0, 0.7);
            --modal-shadow: rgba(0, 0, 0, 0.25);
            --picker-border-color: #555; /* Darker border for color picker */

            /* Grid Colors (Dark) */
            --grid-color: #555;
            --grid-mid-color: #777;
            --grid-reflect-color: #b95f56; /* Adjusted dark */
            --grid-glide-color: #5aa091; /* Adjusted dark */
            --grid-rot-color: #8b609d; /* Adjusted dark */
        }

        *, *::before, *::after { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            display: flex; flex-direction: column; align-items: center;
            background-color: var(--bg-color); color: var(--text-color);
            margin: 0; padding: calc(var(--spacing) * 1.5); min-height: 100vh;
            transition: background-color var(--transition-speed) ease-in-out, color var(--transition-speed) ease-in-out;
            line-height: 1.5;
        }

        .main-container {
            width: 100%; max-width: var(--controls-max-width);
            display: flex; flex-direction: column;
            gap: calc(var(--spacing) * 1.5); /* Increased gap */
        }

        h1 {
            margin-top: 0; margin-bottom: 0.5rem; font-weight: 600; /* Slightly bolder */
            text-align: center; color: var(--text-color); font-size: 2rem; /* Larger */
        }
        .header-area { display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: var(--controls-max-width); margin-bottom: var(--spacing); flex-wrap: wrap; gap: 0.5rem; /* Allow wrapping */ }
        .info-link { margin: 0; color: var(--text-muted); font-size: 0.9em; text-align: center; flex-grow: 1; }
        .info-link button { background: none; border: none; color: var(--primary-color); text-decoration: underline; cursor: pointer; padding: 0; font-size: inherit; font-family: inherit; transition: color var(--transition-speed); }
        .info-link button:hover { color: var(--primary-hover); }

        /* Dark Mode Toggle */
        .theme-switch-wrapper { display: flex; align-items: center; gap: 8px; font-size: 0.85rem; color: var(--text-muted); }
        .theme-switch { display: inline-block; height: 22px; position: relative; width: 44px; }
        .theme-switch input { display: none; }
        .slider { background-color: #ccc; bottom: 0; cursor: pointer; left: 0; position: absolute; right: 0; top: 0; transition: .4s; border-radius: 22px; }
        .slider:before { background-color: #fff; bottom: 3px; content: ""; height: 16px; left: 3px; position: absolute; transition: .4s; width: 16px; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(22px); }
        body.dark-mode .slider { background-color: #555; }
        body.dark-mode .slider:before { background-color: #ddd; }

        .canvas-container {
            position: relative; border: 1px solid var(--canvas-border); background-color: white; /* Canvas bg always white */
            width: 100%; max-width: var(--canvas-width); height: var(--canvas-height);
            box-shadow: 0 0.25rem 0.5rem var(--shadow-color); /* Softer shadow */
            overflow: hidden; margin-left: auto; margin-right: auto; border-radius: var(--border-radius);
            transition: border-color var(--transition-speed);
        }

        #drawingCanvas, #gridCanvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; }
        #drawingCanvas { position: relative; z-index: 0; background-color: white; }
        /* Cursor Classes */
        .cursor-pencil { cursor: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAJ5JREFUOE9jZKASYKSCaxjwv7f0Y2SgKnDqAjsFVQGr4M4L/P9/ZGBgYAZiP6DmkSA1DrBqAQYYGM7/X8y/gYGBgRFFgB0H6sH//0AnAwMDQwIk58/A////MwYGBlYoYP4zMDAwMhACY5EYQ5QBZP7//zMwMDAygALmBDAwMDByMIIAAgyQ0j8wMDAwMsA6sA9A7gAxnwwMAAEEALBwG0+0i3uFAAAAAElFTkSuQmCC') 0 16, crosshair; } /* Embedded pencil */
        .cursor-crosshair { cursor: crosshair; }
        .cursor-default { cursor: default; }

        #gridCanvas { pointer-events: none; z-index: 1; }

        /* Controls Styling */
        .controls-card { background-color: var(--card-bg); padding: calc(var(--spacing) * 1.25); border: 1px solid var(--card-border); border-radius: var(--border-radius); box-shadow: 0 0.25rem 0.5rem var(--shadow-color); width: 100%; max-width: var(--controls-max-width); margin-left: auto; margin-right: auto; transition: background-color var(--transition-speed), border-color var(--transition-speed); }
        .controls-top { display: flex; flex-wrap: wrap; gap: calc(var(--spacing) * 0.75); align-items: center; justify-content: center; margin-bottom: var(--spacing); padding-bottom: var(--spacing); border-bottom: 1px solid var(--card-border); transition: border-color var(--transition-speed); }

        /* General Button Style */
        .btn { display: inline-flex; /* Align icon/text nicely if needed */ align-items: center; justify-content: center; font-weight: 500; /* Slightly bolder */ line-height: 1.5; color: var(--text-color); text-align: center; text-decoration: none; vertical-align: middle; cursor: pointer; user-select: none; background-color: transparent; border: 1px solid transparent; padding: 0.4rem 0.8rem; /* Adjusted padding */ font-size: 0.9rem; border-radius: var(--border-radius); transition: color var(--transition-speed) ease-in-out, background-color var(--transition-speed) ease-in-out, border-color var(--transition-speed) ease-in-out, box-shadow var(--transition-speed) ease-in-out; }
        .btn:disabled { pointer-events: none; opacity: var(--disabled-opacity); }
        .btn:focus-visible { outline: 2px solid var(--primary-color); outline-offset: 2px; } /* Better focus */

        /* Button Variants (Reduced for brevity, same as before) */
        .btn-light { color: var(--light-text); background-color: var(--light-color); border-color: var(--light-color); }
        .btn-light:hover:not(:disabled) { color: var(--light-text); background-color: var(--light-hover); border-color: var(--light-hover); }
        .btn-outline-secondary { color: var(--secondary-color); border-color: var(--secondary-color); }
        .btn-outline-secondary:hover:not(:disabled) { color: var(--secondary-text); background-color: var(--secondary-color); border-color: var(--secondary-color); }
        .btn-outline-danger { color: var(--danger-color); border-color: var(--danger-color); }
        .btn-outline-danger:hover:not(:disabled) { color: #fff; background-color: var(--danger-color); border-color: var(--danger-color); }
        .btn-outline-success { color: var(--success-color); border-color: var(--success-color); }
        .btn-outline-success:hover:not(:disabled) { color: #fff; background-color: var(--success-color); border-color: var(--success-color); }
        .btn-outline-primary { color: var(--primary-color); border-color: var(--primary-color); }
        .btn-outline-primary:hover:not(:disabled) { color: var(--primary-text); background-color: var(--primary-color); border-color: var(--primary-color); }
        .btn-primary { color: var(--primary-text); background-color: var(--primary-color); border-color: var(--primary-color); }
        .btn-primary:hover:not(:disabled) { color: var(--primary-text); background-color: var(--primary-hover); border-color: var(--primary-hover); }
        .btn-outline-info { color: var(--info-color); border-color: var(--info-color); }
        .btn-outline-info:hover:not(:disabled) { color: var(--info-text); background-color: var(--info-color); border-color: var(--info-color); }


        .controls-top label { cursor: pointer; display: inline-flex; align-items: center; gap: 6px; font-size: 0.9rem; padding: 0.375rem 0.5rem; border-radius: var(--border-radius); transition: background-color var(--transition-speed) ease; vertical-align: middle; color: var(--text-muted); }
        .controls-top label:hover { background-color: var(--hover-bg); }
        .controls-top input[type="checkbox"] { cursor: pointer; width: 1.1em; height: 1.1em; margin-top: 0.1em; accent-color: var(--primary-color); border: 1px solid var(--input-border); border-radius: 0.25em; transition: border-color var(--transition-speed); }

        .translation-control { margin-bottom: calc(var(--spacing) * 1.5); padding-bottom: var(--spacing); border-bottom: 1px solid var(--card-border); display: flex; align-items: center; justify-content: center; gap: var(--spacing); flex-wrap: wrap; transition: border-color var(--transition-speed); }
        .translation-control label { font-weight: 500; white-space: nowrap; font-size: 0.9rem; color: var(--text-color); }
        .translation-control input[type="number"] { width: 80px; padding: 0.375rem 0.75rem; font-size: 0.9rem; text-align: center; color: var(--text-color); background-color: var(--card-bg); border: 1px solid var(--input-border); border-radius: var(--border-radius); transition: border-color var(--transition-speed), box-shadow var(--transition-speed), background-color var(--transition-speed), color var(--transition-speed); }
        .translation-control input[type="number"]:focus { color: var(--text-color); background-color: var(--card-bg); border-color: var(--input-focus-border); outline: 0; box-shadow: 0 0 0 0.25rem var(--input-focus-shadow); }

        .options-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); /* Slightly wider min */ gap: calc(var(--spacing) * 1.25) calc(var(--spacing) * 1.5); }
        .control-group { border: none; padding: 0; margin: 0; display: flex; flex-direction: column; }
        .control-group legend { font-weight: 600; margin-bottom: var(--spacing); font-size: 1.05rem; /* Slightly larger */ padding-bottom: 0.6rem; border-bottom: 1px solid var(--card-border); width: 100%; color: var(--text-color); transition: border-color var(--transition-speed), color var(--transition-speed); }
        .control-group label { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; /* Spacing */ cursor: pointer; font-size: 0.9rem; padding: 0.6rem 0.8rem; /* More padding */ border-radius: var(--border-radius); transition: background-color var(--transition-speed) ease-in-out, border-color var(--transition-speed) ease-in-out, color var(--transition-speed); border: 1px solid transparent; position: relative; }
        .control-group label:hover:not(.selected) { background-color: var(--hover-bg); }
        .control-group input[type="radio"] { appearance: none; -webkit-appearance: none; position: absolute; opacity: 0; width: 0; height: 0; }
        .control-group label.selected { background-color: var(--selected-bg); border: 1px solid var(--selected-border); font-weight: 500; color: var(--selected-text); }
        .control-group label.selected::before { content: '✔'; font-size: 0.8em; color: var(--selected-text); margin-right: 5px; line-height: 1; transition: color var(--transition-speed); }

        /* Color Picker Specific Styles */
        .color-picker-group legend { margin-bottom: 0.5rem; /* Less margin for picker */ }
        #colorPickerContainer {
             width: 100%; /* Take full width of its grid column */
             max-width: 250px; /* Optional: Max width if needed */
             margin: 0 auto; /* Center in its column */
             border-radius: var(--border-radius);
             overflow: hidden; /* Ensure children fit */
        }
         /* Style the picker itself - iro.js uses SVG */
        #colorPickerContainer .iro__colorPicker {
            display: block; /* Remove extra space */
            width: 100% !important; /* Force width */
            height: auto !important; /* Maintain aspect ratio */
            border: 1px solid var(--picker-border-color);
            border-radius: var(--border-radius);
            transition: border-color var(--transition-speed);
        }

        /* Info Modal (Reduced for brevity, same as before) */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: var(--modal-backdrop); padding-top: 60px; animation: fadeIn 0.3s ease-out; }
        .modal-content { background-color: var(--card-bg); margin: 5% auto; padding: calc(var(--spacing) * 1.75); border: 1px solid var(--card-border); border-radius: calc(var(--border-radius) * 1.5); width: 90%; max-width: 650px; box-shadow: 0 0.5rem 1rem var(--modal-shadow); position: relative; transition: background-color var(--transition-speed), border-color var(--transition-speed); animation: slideIn 0.3s ease-out; }
        .modal-close { color: var(--text-muted); position: absolute; top: 15px; right: 25px; font-size: 2rem; font-weight: bold; cursor: pointer; line-height: 1; transition: color var(--transition-speed); }
        .modal-close:hover, .modal-close:focus { color: var(--danger-color); text-decoration: none; }
        .modal h2 { margin-top: 0; margin-bottom: var(--spacing); color: var(--primary-color); font-weight: 600; font-size: 1.5rem; }
        .modal p, .modal ul { font-size: 1rem; line-height: 1.7; color: var(--text-color); transition: color var(--transition-speed); }
        .modal ul { padding-left: 25px; margin-bottom: var(--spacing); } .modal li { margin-bottom: 10px; }
        .modal strong { color: var(--primary-color); font-weight: 600; }

        /* Animations */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        /* Responsive (Reduced for brevity, same as before) */
        @media (max-width: 992px) {
             .options-grid { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
             #colorPickerContainer { max-width: 220px; } /* Adjust picker max-width */
        }
        @media (max-width: 768px) {
            body { padding: var(--spacing); }
            h1 { font-size: 1.75rem; }
            .header-area { flex-direction: column; align-items: center; gap: 0.5rem; margin-bottom: var(--spacing) * 1.5; }
            .theme-switch-wrapper { order: -1; margin-bottom: 0.5rem; }
            .controls-top { justify-content: center; flex-wrap: wrap; gap: 0.5rem; }
            .options-grid { grid-template-columns: 1fr; gap: var(--spacing); } /* Single column */
            .modal-content { width: 95%; padding: var(--spacing) * 1.25; }
            .modal h2 { font-size: 1.3rem; }
            .modal p, .modal ul { font-size: 0.95rem; }
             #colorPickerContainer { max-width: 250px; } /* Reset max-width */
        }
         @media (max-width: 480px) {
             .btn { padding: 0.35rem 0.7rem; font-size: 0.85rem; }
             .translation-control input[type="number"] { width: 65px; }
             .control-group label { padding: 0.5rem 0.7rem; }
             h1 { font-size: 1.5rem; }
             #colorPickerContainer { max-width: 200px; } /* Adjust picker max-width */
        }

    </style>
</head>
<body> <!-- Class 'dark-mode' will be added here by JS -->

    <div class="main-container">
        <h1>Simetri Frieze</h1>
        <div class="header-area">
            <div class="info-link">
                 (<button id="infoBtn">Klik di sini</button> untuk info dan instruksi.)
            </div>
            <div class="theme-switch-wrapper">
                <label class="theme-switch" for="themeToggle">
                    <input type="checkbox" id="themeToggle">
                    <span class="slider round"></span>
                </label>
                <span>Mode Gelap</span>
            </div>
        </div>


        <div class="canvas-container">
            <canvas id="drawingCanvas"></canvas>
            <canvas id="gridCanvas"></canvas>
        </div>

        <div class="controls-card">
            <div class="controls-top">
                <button id="undoBtn" title="Urungkan (Ctrl+Z)" class="btn btn-outline-secondary" disabled>Urungkan</button>
                <button id="redoBtn" title="Ulangi (Ctrl+Y)" class="btn btn-outline-secondary" disabled>Ulangi</button>
                <button id="clearBtn" title="Bersihkan Kanvas" class="btn btn-outline-danger">Bersihkan</button>
                <label>
                    <input type="checkbox" id="showGridCheck" checked> Tampilkan Grid
                </label>
                <button id="saveBtn" title="Simpan data gambar sebagai JSON" class="btn btn-outline-success">Simpan JSON</button>
                <button id="loadBtn" title="Muat data gambar dari JSON" class="btn btn-outline-secondary">Muat JSON</button>
                <input type="file" id="loadFile" accept=".json" style="display: none;">
                <button id="downloadImageBtn" title="Unduh gambar sebagai PNG" class="btn btn-outline-info">Unduh Gambar</button>
            </div>

            <div class="translation-control">
                <label for="translationAmount">Translasi (px):</label>
                <input type="number" id="translationAmount" value="200" min="20" step="10">
                 <button id="applyTranslationBtn" class="btn btn-primary">Terapkan</button>
            </div>

            <div class="options-grid">
                <!-- Grup Simetri -->
                <fieldset class="control-group">
                    <legend>Grup Simetri</legend>
                    <label><input type="radio" name="symmetryGroup" value="p111"> <span>p111 (Translasi)</span></label>
                    <label><input type="radio" name="symmetryGroup" value="pm11" checked> <span>pm11 (Refl. Horisontal)</span></label>
                    <label><input type="radio" name="symmetryGroup" value="p1m1"> <span>p1m1 (Refl. Vertikal)</span></label>
                    <label><input type="radio" name="symmetryGroup" value="pmm2"> <span>pmm2 (Refl. H + V)</span></label>
                    <label><input type="radio" name="symmetryGroup" value="p112"> <span>p112 (Rotasi 180°)</span></label>
                    <label><input type="radio" name="symmetryGroup" value="p1a1"> <span>p1a1 (Refl. Geser)</span></label>
                    <label><input type="radio" name="symmetryGroup" value="pma2"> <span>pma2 (Refl. V + Geser)</span></label>
                </fieldset>

                <!-- Alat -->
                <fieldset class="control-group">
                    <legend>Alat Gambar</legend>
                    <label><input type="radio" name="tool" value="line"> <span>Garis</span></label>
                    <label><input type="radio" name="tool" value="rectangle"> <span>Persegi</span></label>
                    <label><input type="radio" name="tool" value="oval" checked> <span>Oval</span></label>
                    <label><input type="radio" name="tool" value="filledRect"> <span>Persegi Isi</span></label>
                    <label><input type="radio" name="tool" value="filledOval"> <span>Oval Isi</span></label>
                    <label><input type="radio" name="tool" value="freehand"> <span>Goresan</span></label>
                </fieldset>

                <!-- Lebar Garis -->
                <fieldset class="control-group">
                    <legend>Lebar Garis (px)</legend>
                    <label><input type="radio" name="lineWidth" value="1"> <span>1</span></label>
                    <label><input type="radio" name="lineWidth" value="2"> <span>2</span></label>
                    <label><input type="radio" name="lineWidth" value="3" checked> <span>3</span></label>
                    <label><input type="radio" name="lineWidth" value="4"> <span>4</span></label>
                    <label><input type="radio" name="lineWidth" value="5"> <span>5</span></label>
                    <label><input type="radio" name="lineWidth" value="10"> <span>10</span></label>
                    <label><input type="radio" name="lineWidth" value="20"> <span>20</span></label>
                </fieldset>

                <!-- Kursor -->
                <fieldset class="control-group">
                    <legend>Gaya Kursor</legend>
                    <label><input type="radio" name="cursorStyle" value="crosshair" checked> <span>Crosshair (+)</span></label>
                    <label><input type="radio" name="cursorStyle" value="pencil"> <span>Pensil</span></label>
                    <label><input type="radio" name="cursorStyle" value="default"> <span>Default (Panah)</span></label>
                </fieldset>

                <!-- Warna (Spectrum Picker) -->
                <div class="control-group color-picker-group">
                     <legend>Warna</legend>
                     <div id="colorPickerContainer"></div>
                </div>

            </div> <!-- End options-grid -->
        </div> <!-- End controls-card -->
    </div> <!-- End main-container -->

    <!-- Info Modal Structure (Same as before) -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="modalCloseBtn">×</span>
            <h2>Informasi & Instruksi Simetri Frieze</h2>
            <p>Aplikasi ini memungkinkan Anda menggambar motif dasar dan melihatnya diulang membentuk pola frieze berdasarkan 7 grup simetri yang berbeda.</p>
            <ul>
                 <li><strong>Pilih Grup Simetri:</strong> Pilih salah satu dari 7 grup untuk transformasi.</li>
                 <li><strong>Pilih Alat & Opsi:</strong> Pilih alat gambar, lebar garis, dan gaya kursor.</li>
                 <li><strong>Pilih Warna:</strong> Gunakan color picker untuk memilih warna gambar. Klik dan seret pada kotak warna dan slider hue.</li>
                 <li><strong>Menggambar:</strong> Klik-tahan-geser pada kanvas putih.</li>
                 <li><strong>Translasi:</strong> Sesuaikan jarak pengulangan dan klik "Terapkan".</li>
                 <li><strong>Grid:</strong> Aktifkan/nonaktifkan garis bantu.</li>
                 <li><strong>Kontrol Lain:</strong> Urungkan, Ulangi, Bersihkan, Simpan/Muat JSON, Unduh PNG.</li>
                 <li><strong>Mode Tampilan:</strong> Gunakan sakelar untuk mode terang/gelap.</li>
            </ul>
            <p><strong>Tips:</strong> Gambar bentuk asimetris kecil dekat tengah atas area gambar untuk melihat efek simetri.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Elemen DOM ---
            const canvas = document.getElementById('drawingCanvas');
            const gridCanvas = document.getElementById('gridCanvas');
            const canvasContainer = document.querySelector('.canvas-container');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const gridCtx = gridCanvas.getContext('2d');
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            const clearBtn = document.getElementById('clearBtn');
            const showGridCheck = document.getElementById('showGridCheck');
            const saveBtn = document.getElementById('saveBtn');
            const loadBtn = document.getElementById('loadBtn');
            const loadFile = document.getElementById('loadFile');
            const downloadImageBtn = document.getElementById('downloadImageBtn');
            const translationAmountInput = document.getElementById('translationAmount');
            const applyTranslationBtn = document.getElementById('applyTranslationBtn');
            const controlGroups = document.querySelectorAll('.control-group:not(.color-picker-group)'); // Exclude color picker group
            const infoBtn = document.getElementById('infoBtn');
            const infoModal = document.getElementById('infoModal');
            const modalCloseBtn = document.getElementById('modalCloseBtn');
            const themeToggle = document.getElementById('themeToggle');
            const colorPickerContainer = document.getElementById('colorPickerContainer'); // Container for iro.js

            // --- Variabel State ---
            let isDrawing = false;
            let currentTool = 'oval';
            let currentColor = '#0000ff'; // Default blue in hex
            let currentLineWidth = 3;
            let currentSymmetryGroup = 'pm11';
            let currentCursorStyle = 'crosshair';
            let translationAmount = parseInt(translationAmountInput.value, 10);
            let startX, startY, currentMouseX, currentMouseY;
            let history = [];
            let historyIndex = -1;
            let drawingActions = [];
            let currentPath = [];
            let lastKnownCanvasState = null;
            let rafId = null;
            let colorPicker = null; // To hold the iro.js instance
            const pencilCursorDataUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAJ5JREFUOE9jZKASYKSCaxjwv7f0Y2SgKnDqAjsFVQGr4M4L/P9/ZGBgYAZiP6DmkSA1DrBqAQYYGM7/X8y/gYGBgRFFgB0H6sH//0AnAwMDQwIk58/A////MwYGBlYoYP4zMDAwMhACY5EYQ5QBZP7//zMwMDAygALmBDAwMDByMIIAAgyQ0j8wMDAwMsA6sA9A7gAxnwwMAAEEALBwG0+0i3uFAAAAAElFTkSuQmCC'; // Embedded pencil cursor


            // --- Setup ---
            function resizeCanvas() {
                const containerWidth = canvasContainer.clientWidth;
                const containerHeight = canvasContainer.clientHeight;
                canvas.width = containerWidth; canvas.height = containerHeight;
                gridCanvas.width = containerWidth; gridCanvas.height = containerHeight;
                // Resize color picker if needed (iro.js often handles this internally based on container)
                if (colorPicker) {
                     // You might not need to call resize explicitly if width is 100%
                     // colorPicker.resize(colorPickerContainer.clientWidth);
                }
                applyContextSettings();
                applyCursorStyle();
                drawGrid();
                redrawAllActions();
            }

            function applyContextSettings(targetCtx = ctx, settings = null) {
                const lw = settings ? settings.lineWidth : currentLineWidth;
                // Use current color from state variable, which is updated by the picker
                const col = settings ? settings.color : currentColor;
                targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round';
                targetCtx.lineWidth = lw; targetCtx.strokeStyle = col; targetCtx.fillStyle = col;
            }

             function applyCursorStyle() {
                 canvas.classList.remove('cursor-pencil', 'cursor-crosshair', 'cursor-default');
                 canvas.style.cursor = ''; // Reset inline cursor style
                 if (currentCursorStyle === 'pencil') {
                     canvas.style.cursor = `url('${pencilCursorDataUrl}') 0 16, crosshair`;
                     canvas.classList.add('cursor-pencil');
                 } else if (currentCursorStyle === 'crosshair') {
                     canvas.classList.add('cursor-crosshair');
                 } else {
                     canvas.classList.add('cursor-default');
                 }
             }

            // --- Initialize Color Picker ---
            function initializeColorPicker() {
                if (colorPickerContainer) {
                    colorPicker = new iro.ColorPicker(colorPickerContainer, {
                        width: colorPickerContainer.clientWidth || 200, // Use container width or default
                        color: currentColor, // Initial color
                        borderWidth: 1,
                        // Use a layout with a box and hue slider
                        layout: [
                          {
                            component: iro.ui.Box,
                            options: {}
                          },
                          {
                            component: iro.ui.Slider,
                            options: {
                              sliderType: 'hue'
                            }
                          }
                        ]
                    });

                    // Update state when color changes
                    colorPicker.on('color:change', function(color) {
                        currentColor = color.hexString;
                        // No need to call applyContextSettings here immediately,
                        // it will be used when drawing starts or redraws happen.
                    });
                } else {
                    console.error("Color picker container not found!");
                }
            }

            // --- Dark Mode Logic ---
            const userPrefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const savedTheme = localStorage.getItem('theme');

            function enableDarkMode() {
                document.body.classList.add('dark-mode');
                themeToggle.checked = true;
                localStorage.setItem('theme', 'dark');
                // Update picker border color (optional, CSS var might handle it)
                if (colorPicker) colorPicker.setOptions({ borderColor: getComputedStyle(document.documentElement).getPropertyValue('--picker-border-color').trim() });
                drawGrid();
            }

            function disableDarkMode() {
                document.body.classList.remove('dark-mode');
                themeToggle.checked = false;
                localStorage.setItem('theme', 'light');
                // Update picker border color (optional)
                if (colorPicker) colorPicker.setOptions({ borderColor: getComputedStyle(document.documentElement).getPropertyValue('--picker-border-color').trim() });
                drawGrid();
            }

            // Apply initial theme
            if (savedTheme === 'dark' || (!savedTheme && userPrefersDark)) {
                enableDarkMode();
            } else {
                disableDarkMode();
            }

            // Theme toggle listener
            themeToggle.addEventListener('change', () => {
                if (themeToggle.checked) {
                    enableDarkMode();
                } else {
                    disableDarkMode();
                }
            });


            // --- Info Modal Logic (Same as before) ---
            function showInfoModal() { infoModal.style.display = 'block'; }
            function hideInfoModal() { infoModal.style.display = 'none'; }
            infoBtn.addEventListener('click', showInfoModal);
            modalCloseBtn.addEventListener('click', hideInfoModal);
            window.addEventListener('click', (event) => { if (event.target == infoModal) hideInfoModal(); });
            window.addEventListener('keydown', (event) => { if (event.key === 'Escape' && infoModal.style.display === 'block') hideInfoModal(); });

            // --- Event Listeners ---
            // Update settings from non-color groups
            controlGroups.forEach(group => {
                group.addEventListener('change', (e) => {
                    if (e.target.type === 'radio') {
                        const previousSymmetry = currentSymmetryGroup;
                        const previousCursor = currentCursorStyle;
                        updateSettings(); // Updates tool, lineWidth, symmetry, cursor
                        updateSelectedLabels(group);
                        if(currentCursorStyle !== previousCursor) applyCursorStyle();
                        if (e.target.name === 'symmetryGroup' && currentSymmetryGroup !== previousSymmetry) {
                            drawGrid(); redrawAllActions(true); saveState();
                        } else if (e.target.name !== 'symmetryGroup') {
                             // No immediate action needed for tool/lineWidth change unless drawing
                        }
                    }
                });
            });

            applyTranslationBtn.addEventListener('click', updateTranslationAmount);
            translationAmountInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') updateTranslationAmount(); });
            showGridCheck.addEventListener('change', toggleGrid);
            clearBtn.addEventListener('click', () => clearCanvas(false));
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            saveBtn.addEventListener('click', saveJson);
            loadBtn.addEventListener('click', () => loadFile.click());
            loadFile.addEventListener('change', loadJson);
            downloadImageBtn.addEventListener('click', downloadCanvasImage);
            document.addEventListener('keydown', (e) => { if (e.ctrlKey || e.metaKey) { if (e.key === 'z' || e.key === 'Z') { e.preventDefault(); undo(); } else if (e.key === 'y' || e.key === 'Y') { e.preventDefault(); redo(); } } });

            // Drawing Listeners
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('touchstart', (e) => { if(e.touches.length === 1) { e.preventDefault(); startDrawing(e.touches[0]); }}, { passive: false });
            // Move/End listeners are added/removed dynamically from window
            window.addEventListener('resize', resizeCanvas); // Add resize listener

            // --- Fungsi Inti ---
            function updateSettings() {
                // Update everything EXCEPT color
                currentTool = document.querySelector('input[name="tool"]:checked')?.value ?? 'oval';
                currentLineWidth = parseInt(document.querySelector('input[name="lineWidth"]:checked')?.value ?? '3', 10);
                // currentColor is updated by the picker's event handler
                currentSymmetryGroup = document.querySelector('input[name="symmetryGroup"]:checked')?.value ?? 'pm11';
                currentCursorStyle = document.querySelector('input[name="cursorStyle"]:checked')?.value ?? 'crosshair';
            }

            function updateSelectedLabels(targetGroup = null) {
                // Update labels for non-color groups
                const groupsToUpdate = targetGroup ? [targetGroup] : controlGroups;
                groupsToUpdate.forEach(group => {
                    group.querySelectorAll('label').forEach(label => {
                         const radio = label.querySelector('input[type="radio"]');
                         if (radio && radio.checked) label.classList.add('selected');
                         else label.classList.remove('selected');
                    });
                });
            }

            function updateTranslationAmount() {
                const newAmount = parseInt(translationAmountInput.value, 10);
                if (!isNaN(newAmount) && newAmount >= 10) {
                     if (translationAmount !== newAmount) {
                        translationAmount = newAmount; drawGrid(); redrawAllActions(true); saveState();
                     }
                } else {
                    alert("Translasi harus angka >= 10."); translationAmountInput.value = translationAmount;
                }
            }

            // --- Manajemen Riwayat (Mostly Same as Before) ---
            function saveState() {
                if (historyIndex < history.length - 1) { history = history.slice(0, historyIndex + 1); drawingActions = drawingActions.slice(0, historyIndex + 1); }
                const maxHistory = 30; if (history.length >= maxHistory) { history.shift(); drawingActions.shift(); } else { historyIndex = history.length; }
                try {
                    const isCanvasBlank = !ctx.getImageData(0, 0, canvas.width, canvas.height).data.some(channel => channel !== 0);
                     if (history.length > 0 || !isCanvasBlank) {
                        const dataUrl = canvas.toDataURL();
                        if (history.length === 0 || history[history.length - 1] !== dataUrl) {
                            history.push(dataUrl); historyIndex = history.length - 1; const img = new Image(); img.onload = () => { lastKnownCanvasState = img; }; img.onerror = () => { lastKnownCanvasState = null; }; img.src = dataUrl;
                        } else { historyIndex = history.length - 1; }
                    } else if (history.length === 0 && isCanvasBlank) {
                        history.push(canvas.toDataURL()); historyIndex = 0; lastKnownCanvasState = null;
                    }
                } catch (e) { console.error("saveState error:", e); } updateUndoRedoButtons();
            }
            function restoreState(targetIndex) {
                 if (targetIndex < 0 || targetIndex >= history.length) return;
                 historyIndex = targetIndex;
                 const dataUrl = history[targetIndex];
                 const img = new Image();
                 img.onload = () => { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0); applyContextSettings(); lastKnownCanvasState = img; const isRestoredBlank = !ctx.getImageData(0, 0, canvas.width, canvas.height).data.some(channel => channel !== 0); if(isRestoredBlank) { lastKnownCanvasState = null; } };
                 img.onerror = () => { console.error("restoreState error: Could not load image for history index", targetIndex); lastKnownCanvasState = null; ctx.clearRect(0, 0, canvas.width, canvas.height); };
                 img.src = dataUrl;
                 updateUndoRedoButtons();
            }
            function undo() { if (historyIndex > 0) restoreState(historyIndex - 1); }
            function redo() { if (historyIndex < history.length - 1) restoreState(historyIndex + 1); }
            function updateUndoRedoButtons() { undoBtn.disabled = historyIndex <= 0; redoBtn.disabled = historyIndex >= history.length - 1; }
            function clearCanvas(isInternal = false) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
                if (!isInternal) {
                    drawingActions = []; history = []; historyIndex = -1;
                    lastKnownCanvasState = null; drawGrid(); saveState();
                    updateUndoRedoButtons();
                    // Optionally reset color picker to default
                    // if (colorPicker) colorPicker.color.hexString = '#0000ff';
                }
            }

            // --- Logika Menggambar (Mostly Same as Before) ---
            function getMousePos(evt) { const rect = canvas.getBoundingClientRect(); const clientX = evt.clientX ?? evt.touches?.[0]?.clientX ?? 0; const clientY = evt.clientY ?? evt.touches?.[0]?.clientY ?? 0; return { x: clientX - rect.left, y: clientY - rect.top }; }
            function startDrawing(e) {
                 if (e.button && e.button !== 0) return; isDrawing = true; const pos = getMousePos(e); startX = pos.x; startY = pos.y; currentMouseX = startX; currentMouseY = startY; applyContextSettings(); if (currentTool === 'freehand') currentPath = [{ x: startX, y: startY }];
                 window.addEventListener('mousemove', handleDrawingMove); window.addEventListener('mouseup', stopDrawing); window.addEventListener('touchmove', handleDrawingMove, { passive: false }); window.addEventListener('touchend', stopDrawing); window.addEventListener('touchcancel', stopDrawing);
                 if (rafId) cancelAnimationFrame(rafId); rafId = requestAnimationFrame(drawingLoop);
            }
            function handleDrawingMove(e) {
                 if (!isDrawing) return; if (e.type === 'touchmove') e.preventDefault(); const pos = getMousePos(e); currentMouseX = pos.x; currentMouseY = pos.y;
                 if (currentTool === 'freehand') { const lastPoint = currentPath[currentPath.length - 1]; const dx = currentMouseX - lastPoint.x; const dy = currentMouseY - lastPoint.y; if (dx * dx + dy * dy > 4) currentPath.push({ x: currentMouseX, y: currentMouseY }); }
            }
            function drawingLoop() {
                 if (!isDrawing) { rafId = null; return; } ctx.clearRect(0, 0, canvas.width, canvas.height); if (lastKnownCanvasState) { try { ctx.drawImage(lastKnownCanvasState, 0, 0); } catch (error) { lastKnownCanvasState = null; console.error("Error drawing last state:", error); redrawAllActions(true); } } applyContextSettings();
                 if (currentTool === 'freehand') { if (currentPath.length > 0) { const tPaths = applySymmetryToPath(currentPath, currentSymmetryGroup); tPaths.forEach(p => drawFreehandPath(p, ctx)); } }
                 else { if (startX !== currentMouseX || startY !== currentMouseY || currentTool === 'line') { const pts = applySymmetry(startX, startY, currentMouseX, currentMouseY, currentSymmetryGroup); pts.forEach(p => drawPrimitive(p.x1, p.y1, p.x2, p.y2, currentTool, ctx)); } else if (startX === currentMouseX && startY === currentMouseY && (currentTool === 'filledRect' || currentTool === 'filledOval')) { const pts = applySymmetry(startX, startY, currentMouseX, currentMouseY, currentSymmetryGroup); pts.forEach(p => drawDot(p.x1, p.y1, ctx)); } }
                 rafId = requestAnimationFrame(drawingLoop);
            }
             function stopDrawing(e) {
                 if (!isDrawing) return; isDrawing = false; window.removeEventListener('mousemove', handleDrawingMove); window.removeEventListener('mouseup', stopDrawing); window.removeEventListener('touchmove', handleDrawingMove); window.removeEventListener('touchend', stopDrawing); window.removeEventListener('touchcancel', stopDrawing);
                 if (rafId) cancelAnimationFrame(rafId); rafId = null; const endX = currentMouseX; const endY = currentMouseY;
                 if (currentTool === 'freehand') { if (currentPath.length > 0) { const last = currentPath[currentPath.length - 1]; if (last.x !== endX || last.y !== endY) currentPath.push({ x: endX, y: endY }); } }
                 let addAction = false; if (currentTool === 'freehand') addAction = currentPath.length > 1; else if (currentTool === 'line') addAction = startX !== endX || startY !== endY; else addAction = true;
                 if (addAction && (currentTool === 'line' || currentTool === 'freehand') && startX === endX && startY === endY) { addAction = false; }
                 if (addAction && (currentTool === 'rectangle' || currentTool === 'oval') && startX === endX && startY === endY) { addAction = false; }

                 if (addAction) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if(lastKnownCanvasState) ctx.drawImage(lastKnownCanvasState, 0, 0);
                    applyContextSettings(); // Apply final settings (includes current color)
                     if (currentTool === 'freehand') {
                        const tPaths = applySymmetryToPath(currentPath, currentSymmetryGroup);
                        tPaths.forEach(p => drawFreehandPath(p, ctx));
                     } else {
                        const pts = applySymmetry(startX, startY, endX, endY, currentSymmetryGroup);
                        pts.forEach(p => {
                            if ((currentTool === 'filledRect' || currentTool === 'filledOval') && startX === endX && startY === endY) drawDot(p.x1, p.y1, ctx);
                            else drawPrimitive(p.x1, p.y1, p.x2, p.y2, currentTool, ctx);
                        });
                     }
                    const action = { tool: currentTool, color: currentColor, lineWidth: currentLineWidth, symmetry: currentSymmetryGroup, startX: startX, startY: startY, endX: endX, endY: endY, path: currentTool === 'freehand' ? [...currentPath] : null };
                    if (historyIndex < history.length - 1) { history = history.slice(0, historyIndex + 1); drawingActions = drawingActions.slice(0, historyIndex + 1); }
                    drawingActions.push(action);
                    saveState();
                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (lastKnownCanvasState) ctx.drawImage(lastKnownCanvasState, 0, 0);
                 }
                 currentPath = [];
            }


            // --- Redraw All Actions (Mostly Same) ---
            function redrawAllActions(dynamicRedraw = false) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const orig = { lineWidth: currentLineWidth, color: currentColor };
                drawingActions.forEach((action) => {
                    // CRITICAL: Use action's color here
                    applyContextSettings(ctx, action);
                    const sym = dynamicRedraw ? currentSymmetryGroup : action.symmetry;
                    if (action.tool === 'freehand') {
                        if (action.path && action.path.length > 0) {
                            const tPaths = applySymmetryToPath(action.path, sym);
                            tPaths.forEach(p => drawFreehandPath(p, ctx));
                        }
                    } else {
                        const pts = applySymmetry(action.startX, action.startY, action.endX, action.endY, sym);
                        pts.forEach(p => {
                            if ((action.tool === 'filledRect' || action.tool === 'filledOval') && action.startX === action.endX && action.startY === action.endY) {
                                drawDot(p.x1, p.y1, ctx);
                            } else {
                                drawPrimitive(p.x1, p.y1, p.x2, p.y2, action.tool, ctx);
                            }
                        });
                    }
                });
                 applyContextSettings(ctx, orig); // Restore current settings
                 if (!isDrawing) {
                     try {
                        const isCanvasBlank = !ctx.getImageData(0, 0, canvas.width, canvas.height).data.some(channel => channel !== 0);
                        if (isCanvasBlank) {
                            lastKnownCanvasState = null;
                        } else {
                            const url = canvas.toDataURL(); const img = new Image(); img.onload = () => { lastKnownCanvasState = img; }; img.onerror = () => { lastKnownCanvasState = null; }; img.src = url;
                        }
                    } catch (e) { console.error("Error updating lastKnownCanvasState in redrawAllActions:", e); lastKnownCanvasState = null; }
                }
            }

            // --- Transformasi Simetri (Same as before) ---
            function applySymmetry(x1, y1, x2, y2, symmetryGroupToUse) { const T = translationAmount; const canvasWidth = canvas.width; const canvasHeight = canvas.height; const midY = canvasHeight / 2; const points = []; const margin = Math.max(5, currentLineWidth * 2); const minXDraw = Math.min(x1, x2) - margin; const maxXDraw = Math.max(x1, x2) + margin; const minYDraw = Math.min(y1, y2) - margin; const maxYDraw = Math.max(y1, y2) + margin; const minN = Math.floor(-maxXDraw / T) - 2; const maxN = Math.ceil((canvasWidth - minXDraw) / T) + 2; for (let n = minN; n <= maxN; n++) { const offsetX = n * T; const t_t = (p) => ({ x1: p.x1 + offsetX, y1: p.y1, x2: p.x2 + offsetX, y2: p.y2 }); const rAx = offsetX + T / 2; const t_vr = (p) => ({ x1: 2 * rAx - p.x1, y1: p.y1, x2: 2 * rAx - p.x2, y2: p.y2 }); const t_hr = (p) => ({ x1: p.x1, y1: 2 * midY - p.y1, x2: p.x2, y2: 2 * midY - p.y2 }); const rCx = offsetX + T / 2; const rCy = midY; const t_rot = (p) => ({ x1: 2 * rCx - p.x1, y1: 2 * rCy - p.y1, x2: 2 * rCx - p.x2, y2: 2 * rCy - p.y2 }); const t_g = (p) => ({ x1: p.x1 + T / 2, y1: 2 * midY - p.y1, x2: p.x2 + T / 2, y2: 2 * midY - p.y2 }); const b = { x1, y1, x2, y2 }; const tr = t_t(b); const candidates = [tr]; switch (symmetryGroupToUse) { case 'p111': break; case 'pm11': candidates.push(t_hr(tr)); break; case 'p1m1': candidates.push(t_vr(tr)); break; case 'p112': candidates.push(t_rot(tr)); break; case 'pmm2': candidates.push(t_hr(tr)); candidates.push(t_vr(tr)); candidates.push(t_rot(tr)); break; case 'p1a1': candidates.push(t_g(tr)); break; case 'pma2': const vr_pma2 = t_vr(tr); candidates.push(vr_pma2); const g_pma2 = t_g(tr); candidates.push(g_pma2); candidates.push(t_vr(g_pma2)); break; } candidates.forEach(p => { const pMinX = Math.min(p.x1, p.x2); const pMaxX = Math.max(p.x1, p.x2); const pMinY = Math.min(p.y1, p.y2); const pMaxY = Math.max(p.y1, p.y2); if (pMaxX >= -margin && pMinX <= canvasWidth + margin && pMaxY >= -margin && pMinY <= canvasHeight + margin) { points.push(p); } }); } return points; }
            function applySymmetryToPath(path, symmetryGroupToUse) { if (!path || path.length === 0) return []; const T = translationAmount; const cW = canvas.width; const cH = canvas.height; const mY = cH / 2; const tPaths = []; const mg = Math.max(5, currentLineWidth * 2); let minX = path[0].x, maxX = path[0].x, minY = path[0].y, maxY = path[0].y; path.forEach(p => { minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x); minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y); }); minX -= mg; maxX += mg; minY -= mg; maxY += mg; const minN = Math.floor(-maxX / T) - 2; const maxN = Math.ceil((cW - minX) / T) + 2; for (let n = minN; n <= maxN; n++) { const oX = n * T; const tp_t = (p) => ({ x: p.x + oX, y: p.y }); const rAx = oX + T / 2; const tp_vr = (p) => ({ x: 2 * rAx - p.x, y: p.y }); const tp_hr = (p) => ({ x: p.x, y: 2 * mY - p.y }); const rCx = oX + T / 2; const rCy = mY; const tp_rot = (p) => ({ x: 2 * rCx - p.x, y: 2 * rCy - p.y }); const tp_g = (p) => ({ x: p.x + T / 2, y: 2 * mY - p.y }); const appTrans = (op, pt) => op.map(pt); const trPath = appTrans(path, tp_t); const candidatePaths = [trPath]; switch (symmetryGroupToUse) { case 'p111': break; case 'pm11': candidatePaths.push(appTrans(trPath, tp_hr)); break; case 'p1m1': candidatePaths.push(appTrans(trPath, tp_vr)); break; case 'p112': candidatePaths.push(appTrans(trPath, tp_rot)); break; case 'pmm2': candidatePaths.push(appTrans(trPath, tp_hr)); candidatePaths.push(appTrans(trPath, tp_vr)); candidatePaths.push(appTrans(trPath, tp_rot)); break; case 'p1a1': candidatePaths.push(appTrans(trPath, tp_g)); break; case 'pma2': const vrPath = appTrans(trPath, tp_vr); candidatePaths.push(vrPath); const gPath = appTrans(trPath, tp_g); candidatePaths.push(gPath); candidatePaths.push(appTrans(gPath, tp_vr)); break; } candidatePaths.forEach(cp => { let pathVisible = false; for(const p of cp) { if (p.x >= -mg && p.x <= cW + mg && p.y >= -mg && p.y <= cH + mg) { pathVisible = true; break; } } if (pathVisible) tPaths.push(cp); }); } return tPaths; }

            // --- Menggambar Primitif (Same as before) ---
            function drawPrimitive(x1, y1, x2, y2, tool, targetCtx) { targetCtx.beginPath(); const w = x2 - x1; const h = y2 - y1; switch (tool) { case 'line': targetCtx.moveTo(x1, y1); targetCtx.lineTo(x2, y2); targetCtx.stroke(); break; case 'rectangle': case 'filledRect': targetCtx.rect(x1, y1, w, h); if (tool === 'filledRect') targetCtx.fill(); else targetCtx.stroke(); break; case 'oval': case 'filledOval': const rX = Math.abs(w / 2); const rY = Math.abs(h / 2); const cX = x1 + w / 2; const cY = y1 + h / 2; if (rX > 0 && rY > 0) { targetCtx.ellipse(cX, cY, rX, rY, 0, 0, 2 * Math.PI); if (tool === 'filledOval') targetCtx.fill(); else targetCtx.stroke(); } else if (rX > 0 || rY > 0) { } else { drawDot(x1,y1, targetCtx); } break; } }
            function drawFreehandPath(path, targetCtx) { if (!path || path.length === 0) return; targetCtx.beginPath(); targetCtx.moveTo(path[0].x, path[0].y); if (path.length === 1) drawDot(path[0].x, path[0].y, targetCtx); else { for (let i = 1; i < path.length; i++) targetCtx.lineTo(path[i].x, path[i].y); targetCtx.stroke(); } }
            function drawDot(x, y, targetCtx) { const r = Math.max(0.5, targetCtx.lineWidth / 2); targetCtx.fillStyle = targetCtx.strokeStyle; targetCtx.beginPath(); targetCtx.ellipse(x, y, r, r, 0, 0, 2 * Math.PI); targetCtx.fill(); }

            // --- Grid Dinamis (Same as before) ---
            function toggleGrid() { gridCanvas.style.display = showGridCheck.checked ? 'block' : 'none'; if (showGridCheck.checked) drawGrid(); else gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height); }
            function drawGrid() { if (!showGridCheck.checked) { gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height); return; } gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height); const T = translationAmount; const mY = gridCanvas.height / 2; const w = gridCanvas.width; const h = gridCanvas.height; const rotR = 4; gridCtx.save(); gridCtx.lineWidth = 1; const st = getComputedStyle(document.documentElement); const gC = st.getPropertyValue('--grid-color').trim() || '#B0BEC5'; const gMC = st.getPropertyValue('--grid-mid-color').trim() || '#90A4AE'; const gRC = st.getPropertyValue('--grid-reflect-color').trim() || '#F1948A'; const gGC = st.getPropertyValue('--grid-glide-color').trim() || '#76D7C4'; const gRotC = st.getPropertyValue('--grid-rot-color').trim() || '#AF7AC5'; gridCtx.strokeStyle = gC; gridCtx.setLineDash([4, 4]); const minNGrid = Math.floor(-w / T) - 2; const maxNGrid = Math.ceil(w / T) + 2; for (let n = minNGrid; n <= maxNGrid; n++) { const x = n * T; if (x > -5 && x < w + 5) { gridCtx.beginPath(); gridCtx.moveTo(x, 0); gridCtx.lineTo(x, h); gridCtx.stroke(); } } gridCtx.setLineDash([]); switch (currentSymmetryGroup) { case 'pm11': case 'pmm2': gridCtx.strokeStyle = gMC; gridCtx.lineWidth = 1.2; gridCtx.beginPath(); gridCtx.moveTo(0, mY); gridCtx.lineTo(w, mY); gridCtx.stroke(); break; case 'p1a1': case 'pma2': gridCtx.strokeStyle = gGC; gridCtx.lineWidth = 1.2; gridCtx.setLineDash([8, 4]); gridCtx.beginPath(); gridCtx.moveTo(0, mY); gridCtx.lineTo(w, mY); gridCtx.stroke(); break; default: gridCtx.strokeStyle = gMC; gridCtx.lineWidth = 0.8; gridCtx.setLineDash([2, 3]); gridCtx.beginPath(); gridCtx.moveTo(0, mY); gridCtx.lineTo(w, mY); gridCtx.stroke(); break; } gridCtx.setLineDash([]); gridCtx.lineWidth = 1; for (let n = minNGrid; n <= maxNGrid; n++) { const cX = n * T + T / 2; if (cX > -rotR && cX < w + rotR) { if (currentSymmetryGroup === 'p1m1' || currentSymmetryGroup === 'pmm2' || currentSymmetryGroup === 'pma2') { gridCtx.strokeStyle = gRC; gridCtx.lineWidth = 1.2; gridCtx.beginPath(); gridCtx.moveTo(cX, 0); gridCtx.lineTo(cX, h); gridCtx.stroke(); } if (currentSymmetryGroup === 'p112' || currentSymmetryGroup === 'pmm2' || currentSymmetryGroup === 'pma2') { gridCtx.fillStyle = gRotC; gridCtx.beginPath(); gridCtx.ellipse(cX, mY, rotR, rotR, 0, 0, 2 * Math.PI); gridCtx.fill(); } } } gridCtx.restore(); }

            // --- Simpan / Muat JSON ---
            function saveJson() { if (drawingActions.length === 0) { alert("Tidak ada data untuk disimpan."); return; } const data = { version: 1.8, translationAmount: translationAmount, actions: drawingActions }; const str = JSON.stringify(data, null, 2); const blob = new Blob([str], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); const t = new Date().toISOString().replace(/[:.]/g, '-'); a.download = `frieze_drawing_${currentSymmetryGroup}_T${translationAmount}_${t}.json`; a.href = url; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }
            function loadJson(event) { const f = event.target.files[0]; if (!f || !f.type.match('application/json')) { alert("Pilih file JSON."); loadFile.value = null; return; } const r = new FileReader(); r.onload = (e) => { try { const d = JSON.parse(e.target.result); if (!d || typeof d.translationAmount !== 'number' || !Array.isArray(d.actions)) throw new Error("Format JSON tidak valid."); clearCanvas(true); translationAmountInput.value = d.translationAmount; translationAmount = d.translationAmount; drawingActions = d.actions; if (drawingActions.length > 0) { const lastAction = drawingActions[drawingActions.length - 1]; const sym = lastAction.symmetry || 'pm11'; const tool = lastAction.tool || 'oval'; const lw = lastAction.lineWidth || 3; const col = lastAction.color || '#0000ff'; // Use loaded color
                        const rS = document.querySelector(`input[name="symmetryGroup"][value="${sym}"]`); if (rS) rS.checked = true; else document.querySelector('input[name="symmetryGroup"][value="pm11"]').checked = true;
                        const rT = document.querySelector(`input[name="tool"][value="${tool}"]`); if(rT) rT.checked = true;
                        const rL = document.querySelector(`input[name="lineWidth"][value="${lw}"]`); if(rL) rL.checked = true;
                        // Set color picker's color
                        if (colorPicker) { colorPicker.color.hexString = col; }
                        currentColor = col; // Update state variable too
                    } else { document.querySelector('input[name="symmetryGroup"][value="pm11"]').checked = true; if (colorPicker) colorPicker.color.hexString = '#0000ff'; currentColor = '#0000ff'; } // Reset to defaults if no actions
                    updateSettings(); updateSelectedLabels(); applyCursorStyle(); drawGrid(); redrawAllActions(false); history = []; historyIndex = -1; lastKnownCanvasState = null; saveState();
                     alert(`Gambar "${f.name}" dimuat.`);
                 } catch (err) { console.error("Load JSON error:", err); alert("Gagal memuat: " + err.message); clearCanvas(); } finally { loadFile.value = null; } }; r.onerror = () => { alert("Tidak bisa membaca file."); loadFile.value = null; }; r.readAsText(f); }

            // --- Unduh Gambar (Same as before) ---
            function downloadCanvasImage() {
                let finalCanvas = canvas;
                if (showGridCheck.checked && gridCanvas.style.display !== 'none') {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width; tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = 'white'; tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(gridCanvas, 0, 0);
                    tempCtx.drawImage(canvas, 0, 0);
                    finalCanvas = tempCanvas;
                }
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `frieze_pattern_${currentSymmetryGroup}_T${translationAmount}_${timestamp}.png`;
                const link = document.createElement('a'); link.download = filename;
                try {
                    link.href = finalCanvas.toDataURL('image/png');
                    document.body.appendChild(link); link.click(); document.body.removeChild(link);
                    if (finalCanvas !== canvas) { finalCanvas = null; }
                } catch (e) { console.error("Download image error:", e); alert("Gagal membuat gambar unduhan."); }
            }

            // --- Panggilan Setup Awal ---
            initializeColorPicker(); // Initialize the picker first
            updateSettings(); // Update other settings
            updateSelectedLabels();
            applyCursorStyle();
            resizeCanvas();
            toggleGrid();
            updateUndoRedoButtons();
            saveState();
            console.log("Frieze Drawer (v1.8 - Spectrum Color Picker) Initialized.");
        }); // End DOMContentLoaded
    </script>

</body>
</html>
